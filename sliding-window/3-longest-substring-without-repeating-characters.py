#https://leetcode.com/problems/longest-substring-without-repeating-characters/description/

# Optimal solution
# Time complexity - O(n) т.к. проходимся по всем эл-ам в худшем случае
# Memory complexity - O(n) т.к. храним в памяти сет
#Idea: Создаем пустой сет для хранения подстрок, а также счетчик для подстчета историч максимума самой длинной
# подстроки и переменную для левого указателя. Идем от первого эл-та, пробегаемся по листу s и, пока текущий
# рассматриваемый элемент находится в сете, удаляем все эл-ты слева от повторяющегося эл-та. Когда все удалили,
# добавляем эл-ты в сет до тех пор, пока снова не попадем в цикл while и пока не увидим повторяющийся эл-т. Там же
# обновляем исторический максимум длины подстроки, если он оказался выше текущего историч максимума (r-l+1).
# В ф-ии возвращаем исторический максимум самой длинной подстроки


class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        substr = set()
        max_length = 0 #счетчик для обновления историч максимума длины substring
        l = 0 #для скользящего окна будем поджимать значения и удалять ненужное слева
        for r in range(len(s)):
            while s[r] in substr:
                substr.remove(s[l])
                l += 1 #для движения скользящего окна и удаления эл-ов до повторяющ-ся эл-та слева
            substr.add(s[r])
            max_length = max(max_length, r-l+1) #выбираем макс между историч максимумом и длины подстроки
        return max_length
